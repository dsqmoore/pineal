#!/usr/bin/env hy

(import
  [time [sleep]]
  [core.windows [new-renderer new-master new-overview]]
  [core.nerve [nerve-cb! nerve-start]]
  [core.pyexec [pyexec]])

(require core.runner)


(runner Eye [conf]
        "
        Handles and draws the different visions

        Recives from Coder:
        * `/eye/code    [filename code]`
        * `/eye/delete  [filename]` (not yet implemented)
        * `/eye/move    [oldname newname]`

        Sends to Ear:
        * `/ear/code  [cmd]`
          signal generated by lib.audio.source

        Recives from Ear:
        * `/eye/audio/[cmd]  [value]`
          signal handled by lib.audio.source
        "
        (print "starting eye.hy")

        ; update impure config
        (import [core
                 [conf :as impure-conf]])
        (setv impure-conf.RENDER-SIZE conf.RENDER-SIZE)
        (setv impure-conf.OSC-EYE     conf.OSC-EYE)

        (setv visions {})

        (setv renderer (new-renderer visions
                                     conf.RENDER-SIZE))
        (new-master renderer)
        (new-overview renderer)

        (nerve-cb! "/eye/code"
                   (fn [path args]
                     (setv [name code] args)
                     (if (in name (visions.keys))
                       (.load (get visions name)
                              code)
                       (assoc visions
                         name
                         (new-vision name code)))))

        (setv nerve-stop (nerve-start))

        (import [pyglet])
        (.schedule_interval pyglet.clock
                            (fn [dt]
                              ; TODO: undefined?
                              ; NO, macro-magic!
                              (when (car _stop)
                                (.exit pyglet.app)))
                            (/ 1 120))
        (try
          (.run pyglet.app)
          (catch [KeyboardInterrupt]
            None))

        (print "\rstopping eye.hy")
        (nerve-stop))


(defn new-vision [path code]
  (setv name
    (get (.split path "/") -1))

  ; stack here the loaded codes,
  ; so when everything explodes, we can
  ; always restore the last (opefully) working vision
  (setv stack [])

  (defclass Box []
    "A small sandbox where to run the livecoded part"
    [[draw
      (fn [self])]])

  (setv box (Box))

  (defclass Vision []
    "
    The vision instance
    "
    [[load
      (fn [self code]
        (print "\rloading:" name)
        (setv filename (% "visions/%s" name))
        (try
          (pyexec code box.__dict__)
          (except [e Exception]
            (print name e))
          (else
            (.append stack code))))]

     [iteration
      (fn [self]
        (try
          (.draw box)
          ; if there is an error and stack is empty
          ; the FIRST loaded vision is broken
          (except [e Exception]
            (print name name e)
            (.pop stack)

            (if stack
              (pyexec (get stack -1)
                      box.__dict__)
              (print name "BROKEN!")))))]])

  (setv vision (Vision))
  (.load vision code)
  vision)


(defmain [args]
  (.run (Eye)))
