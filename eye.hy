#!/usr/bin/env hy2

(import
  [time [sleep]]
  [lib.runner [Runner]]
  [lib.windows [Renderer Master Overview]]
  [lib.osc [nerve]]
  [lib.pyexec [pyexec]]
  [config [OSC_EAR OSC_EYE]])


(defclass Eye [Runner]
  "
  Handles and draws the different visions

  Recives from Coder:
  * `/eye/code    [filename code]`
  * `/eye/delete  [filename]` (not yet implemented)
  * `/eye/move    [oldname newname]`

  Sends to Ear:
  * `/ear/code  [cmd]` signal generated by lib.audio.source

  Recives from Ear:
  * `/eye/audio/[cmd]  [value]` signal handled by lib.audio.source

  Recives from Universe:
  * `[anything]  [?]` signal handled by lib.osc.source (not tested)
  "
  [[__init__
      (fn [self]
          (.__init__ Runner self)
          (setv self.visions {})
          (setv self.renderer None)
          (.sender nerve OSC_EAR)
          (.receiver nerve OSC_EYE))]

   [run
     (fn [self]
         (print "starting eye.hy")

         (.listen nerve "/eye/code" self.coder)
         (.listen nerve "/eye/move" self.moved)
         ;(.listen nerve "/eye/delete" self.deleted)

         (.start nerve)

         ; windows
         ; for now just one renderer -> TODO one for each vision
         (setv self.renderer (Renderer self.visions))
         (setv master (Master))
         (setv overview (Overview))

         (.while-not-stopped self
                             (fn []
                                 (.update self.renderer)
                                 (.update overview [self.renderer.texture])
                                 (.update master [self.renderer.texture])))

         (print "\rstopping eye.hy")
         (.stop nerve))]

   [coder
     (fn [self path args]
         (setv [name code] args)
         (if (in name (self.visions.keys))
           (.load (get self.visions name)
                    code)
           (assoc self.visions
                  name
                  (Vision name code self.renderer))))]

   [moved
     (fn [self path args]
         (setv [oldname newname] args)
         (when (in oldname (self.visions.keys))
           (.setName (get self.visions oldname)
                     newname)
           (assoc self.visions
                  newname
                  (.pop self.visions oldname))))]])


(defclass Vision []
  "
  The vision instance
  "
  [[__init__
      (fn [self name code renderer]  ; TODO renderer generation INSIDE
          (.setName self name)
          (setv self.renderer renderer)

          ; stack here the loaded codes, so when everything explodes, we can
          ; always restore the last (opefully) working vision
          (setv self.stack [])

          (defclass Box []
            "A small sandbox where to run the livecoded part"
            [[draw
                (fn [self])]])

          (setv self.box (Box))

          (.load self code)
          None)]

   [setName
     (fn [self name]
         (setv self.name
               (get (.split name "/") -1)))]

   [load
     (fn [self code]
         (print "\rloading:" self.name)
         (setv filename (% "visions/%s" self.name))
         (try
           (pyexec code self.box.__dict__)
           (except [e Exception]
                   (print self.name e))
           (else
             (.append self.stack code))))]

   [iteration
     (fn [self]
         (try
           (.draw self)
           ; if there is an error and stack is empty you are in the situation
           ; where the FIRST loaded vision is broken, that can be a problem
           ; (for you, if you are livecoding)
           (except [e Exception]
                   (print self.name self.name e)
                   (.pop self.stack)

                   (if self.stack
                     (pyexec (get self.stack -1)
                             self.box.__dict__)
                     (print self.name "BROKEN!")))))]

   [draw
     (fn [self]
         (.draw self.box))]])


(defmain [args]
  (.run (Eye)))
