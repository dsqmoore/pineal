#!/usr/bin/env hy2

(import
  [time [sleep]]
  [lib.windows [Renderer Master Overview]]
  [lib.osc [nerve-cb! nerve-start]]
  [lib.pyexec [pyexec]])

(require lib.runner)


(runner Eye [self]
        "
        Handles and draws the different visions

        Recives from Coder:
        * `/eye/code    [filename code]`
        * `/eye/delete  [filename]` (not yet implemented)
        * `/eye/move    [oldname newname]`

        Sends to Ear:
        * `/ear/code  [cmd]` signal generated by lib.audio.source

        Recives from Ear:
        * `/eye/audio/[cmd]  [value]` signal handled by lib.audio.source

        Recives from Universe:
        * `[anything]  [?]` signal handled by lib.osc.source (not tested)
        "
        (print "starting eye.hy")

        (setv visions {})

        ; windows
        ; for now just one renderer -> TODO one for each vision
        (setv renderer (Renderer visions))
        (setv master (Master))
        (setv overview (Overview))

        (nerve-cb! "/eye/code"
                   (fn [path args]
                       (setv [name code] args)
                       (if (in name (visions.keys))
                         (.load (get visions name)
                                code)
                         (assoc visions
                                name
                                (Vision name code renderer)))))

        (setv nerve-stop (nerve-start))

        (running
          (.update renderer)
          (.update overview [renderer.texture])
          (.update master [renderer.texture]))

        (print "\rstopping eye.hy")
        (nerve-stop))


(defclass Vision []
  "
  The vision instance
  "
  [[__init__
     (fn [self name code renderer]  ; TODO renderer generation INSIDE
         (setv self.name
               (get (.split name "/") -1))
         (setv self.renderer renderer)

         ; stack here the loaded codes, so when everything explodes, we can
         ; always restore the last (opefully) working vision
         (setv self.stack [])

         (defclass Box []
           "A small sandbox where to run the livecoded part"
           [[draw
              (fn [self])]])

         (setv self.box (Box))

         (.load self code)
         None)]

   [load
     (fn [self code]
         (print "\rloading:" self.name)
         (setv filename (% "visions/%s" self.name))
         (try
           (pyexec code self.box.__dict__)
           (except [e Exception]
                   (print self.name e))
           (else
             (.append self.stack code))))]

   [iteration
     (fn [self]
         (try
           (.draw self.box)
           ; if there is an error and stack is empty you are in the situation
           ; where the FIRST loaded vision is broken, that can be a problem
           ; (for you, if you are livecoding)
           (except [e Exception]
                   (print self.name self.name e)
                   (.pop self.stack)

                   (if self.stack
                     (pyexec (get self.stack -1)
                             self.box.__dict__)
                     (print self.name "BROKEN!")))))]])


(defmain [args]
  (.run (Eye)))
